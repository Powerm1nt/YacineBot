import { stopScheduler, initScheduler, getSchedulerStatus, getNextChannel, getTaskByNumber, setDefaultChannelType, CHANNEL_TYPES, getTargetingStats, setTaskChannelType } from '../services/schedulerService.js';

// Importer la fonction formatDelay depuis schedulerService.js
import { formatDelay } from '../services/schedulerService.js';
// Importer les fonctions depuis messageUtils.js
import { sendLongMessage, checkAndRegenerateTasks } from '../utils/messageUtils.js';

// M√©tadonn√©es de la commande
export const metadata = {
  name: 'scheduler',
  description: 'G√®re le planificateur de t√¢ches automatiques',
  restricted: true,
};

/**
 * Commande pour g√©rer le planificateur de t√¢ches
 * @param {Object} client - Client Discord
 * @param {Object} message - Message Discord
 * @param {Array} args - Arguments de la commande
 */
export async function scheduler(client, message, args) {
  if (!args.length) {
    message.reply('‚ùå Utilisation : scheduler <start|stop|status|stats>');
    return;
  }

  const action = args[0].toLowerCase();

  switch (action) {
    case 'start':
      initScheduler(client);
      message.reply(`‚úÖ Planificateur de t√¢ches d√©marr√© ! Les messages al√©atoires seront envoy√©s entre ${process.env.MIN_DELAY_MINUTES || '10'} et ${process.env.MAX_DELAY_MINUTES || '120'} minutes, pendant les heures actives (8h-23h).`);
      break;

    case 'restart':
      initScheduler(client);
      message.reply(`üîÑ Planificateur red√©marr√© avec de nouvelles t√¢ches al√©atoires.`);
      break;

          case 'stats':
      const statsStatus = getSchedulerStatus();

      if (!statsStatus.active) {
        message.reply('‚ÑπÔ∏è Aucune statistique disponible. Le planificateur est arr√™t√©.');
        return;
      }

      // V√©rifier s'il n'y a plus de t√¢ches actives et les r√©g√©n√©rer si n√©cessaire
      if (statsStatus.tasks.length === 0) {
        const regenerated = checkAndRegenerateTasks(client);
        if (regenerated) {
          message.reply('‚ö†Ô∏è Aucune t√¢che active d√©tect√©e. Le planificateur a √©t√© automatiquement red√©marr√© avec de nouvelles t√¢ches.');
          // Rafra√Æchir le statut apr√®s la r√©g√©n√©ration
          const refreshedStatus = getSchedulerStatus();
          statsStatus.tasks = refreshedStatus.tasks;
          statsStatus.taskCount = refreshedStatus.taskCount;
          statsStatus.nextTask = refreshedStatus.nextTask;
        } else {
          message.reply('‚ö†Ô∏è Aucune t√¢che active et impossible de r√©g√©n√©rer. Essayez de red√©marrer manuellement avec `f!scheduler restart`');
          return;
        }
      }

      // Cr√©er un rapport de statistiques
      let statsMessage = `üìà **Statistiques du planificateur**\n\n`;

      // Distribution des d√©lais
      const delays = statsStatus.tasks.map(t => t.timeLeftMs);
      const minTaskDelay = Math.min(...delays);
      const maxTaskDelay = Math.max(...delays);
      const avgDelay = delays.reduce((sum, val) => sum + val, 0) / delays.length;

      statsMessage += `‚è±Ô∏è **D√©lais actuels:**\n`;
      statsMessage += `‚ñ´Ô∏è Minimum: **${formatDelay(minTaskDelay)}**\n`;
      statsMessage += `‚ñ´Ô∏è Maximum: **${formatDelay(maxTaskDelay)}**\n`;
      statsMessage += `‚ñ´Ô∏è Moyenne: **${formatDelay(avgDelay)}**\n\n`;

      // Configuration
      statsMessage += `‚öôÔ∏è **Configuration:**\n`;
      statsMessage += `‚ñ´Ô∏è Plage de d√©lai: **${statsStatus.config.minDelay}** √† **${statsStatus.config.maxDelay}**\n`;
      statsMessage += `‚ñ´Ô∏è T√¢ches configur√©es: **${statsStatus.config.minTasks}** √† **${statsStatus.config.maxTasks}**\n`;
      statsMessage += `‚ñ´Ô∏è T√¢ches actives: **${statsStatus.taskCount}**\n\n`;

      // Statistiques d√©taill√©es sur les cibles
      const targetingStats = getTargetingStats();

      statsMessage += `üìä **Distribution des canaux:**\n`;
      statsMessage += `‚ñ´Ô∏è Serveurs: **${targetingStats.channels.guild.count}** t√¢ches\n`;
      statsMessage += `‚ñ´Ô∏è Messages priv√©s: **${targetingStats.channels.dm.count}** t√¢ches\n`;
      statsMessage += `‚ñ´Ô∏è Groupes: **${targetingStats.channels.group.count}** t√¢ches\n`;
      statsMessage += `‚ñ´Ô∏è En attente d'attribution: **${targetingStats.channels.pending}** t√¢ches\n\n`;

      // Ajouter les serveurs les plus cibl√©s s'il y en a
      if (targetingStats.guilds.count > 0) {
        const guildEntries = Object.entries(targetingStats.guilds.names);
        if (guildEntries.length > 0) {
          statsMessage += `üè† **Serveurs cibl√©s:**\n`;
          guildEntries.sort((a, b) => b[1] - a[1]).slice(0, 3).forEach(([name, count]) => {
            statsMessage += `‚ñ´Ô∏è ${name}: **${count}** t√¢che(s)\n`;
          });
          statsMessage += `\n`;
        }
      }

      // Ajouter les utilisateurs les plus cibl√©s s'il y en a
      if (targetingStats.users.count > 0) {
        const userEntries = Object.entries(targetingStats.users.names);
        if (userEntries.length > 0) {
          statsMessage += `üë§ **Utilisateurs cibl√©s:**\n`;
          userEntries.sort((a, b) => b[1] - a[1]).slice(0, 3).forEach(([name, count]) => {
            statsMessage += `‚ñ´Ô∏è ${name}: **${count}** mention(s)\n`;
          });
          statsMessage += `\n`;
        }
      }

      // Prochaine ex√©cution
      if (statsStatus.nextTask) {
        statsMessage += `‚è∞ **Prochaine ex√©cution dans:** ${statsStatus.nextTask.timeLeft}\n`;
      }

      // Utiliser sendLongMessage pour √©viter l'erreur de limite de caract√®res
      await sendLongMessage(message.channel, statsMessage, { reply: message.reply.bind(message) });
      break;

    case 'stop':
      stopScheduler();
      message.reply('‚úÖ Planificateur de t√¢ches arr√™t√©. Plus aucun message automatique ne sera envoy√©.');
      break;

    case 'status':
      const status = getSchedulerStatus();

      // Pr√©visualiser le prochain canal si pas d√©j√† disponible
      if (!status.nextChannel) {
        getNextChannel(client);
      }

      if (!status.active) {
        message.reply('‚ÑπÔ∏è Le planificateur est actuellement arr√™t√©. Utilisez `f!scheduler start` pour le d√©marrer.');
        return;
      }

      // V√©rifier s'il n'y a plus de t√¢ches actives et les r√©g√©n√©rer si n√©cessaire
      if (status.tasks.length === 0) {
        const regenerated = checkAndRegenerateTasks(client);
        if (regenerated) {
          message.reply('‚ö†Ô∏è Aucune t√¢che active d√©tect√©e. Le planificateur a √©t√© automatiquement red√©marr√© avec de nouvelles t√¢ches.');
          // Rafra√Æchir le statut apr√®s la r√©g√©n√©ration
          const refreshedStatus = getSchedulerStatus();
          status.tasks = refreshedStatus.tasks;
          status.taskCount = refreshedStatus.taskCount;
          status.nextTask = refreshedStatus.nextTask;
        }
      }

      // Construire le message complet
      let statusMessage = `üìä **√âtat du planificateur**\n\n`;
      statusMessage += `‚è∞ Heure actuelle: **${status.currentTime}** (${status.timezone})\n`;
      statusMessage += `üîÑ **${status.taskCount}** t√¢che(s) active(s)\n`;
      statusMessage += `üïí Plage horaire active: **${status.config.activeHours}** (${status.inActiveHours ? '‚úÖ actif' : '‚ùå inactif'})\n`;
      statusMessage += `‚è±Ô∏è D√©lai configur√©: **${status.config.minDelay}** - **${status.config.maxDelay}**\n`;
      statusMessage += `üî¢ T√¢ches configur√©es: **${status.config.minTasks}** - **${status.config.maxTasks}**\n\n`;

      // Ajouter les informations sur la prochaine ex√©cution et le canal pr√©visualis√©
      if (status.nextTask) {
        statusMessage += `‚è∞ **Prochaine ex√©cution**: T√¢che #${status.nextTask.number} dans **${status.nextTask.timeLeft}** (${status.nextTask.nextExecution})\n`;

        // Ajouter l'information sur le canal pr√©visualis√©
        if (status.nextChannel) {
          let channelInfo = '';

          switch (status.nextChannel.type) {
            case 'guild':
              channelInfo = `üè† **Prochain canal**: Serveur **${status.nextChannel.guildName}** (salon: ${status.nextChannel.name})`;
              break;
            case 'dm':
              channelInfo = `üë§ **Prochain canal**: MP avec **${status.nextChannel.username}**`;
              break;
            case 'group':
              channelInfo = `üë• **Prochain canal**: Groupe **${status.nextChannel.name}** (${status.nextChannel.memberCount} membres)`;
              break;
          }

          statusMessage += `${channelInfo}\n`;
          statusMessage += `‚ÑπÔ∏è Cette pr√©visualisation peut changer si le canal devient indisponible\n\n`;
        } else {
          statusMessage += `\n`;
        }
      }

      // Ajouter la liste des t√¢ches planifi√©es
      if (status.tasks.length > 0) {
        statusMessage += `**Toutes les t√¢ches planifi√©es:**\n`;
        status.tasks.forEach(task => {
          let targetInfo = "";

          // Ajouter des informations sur la cible si disponibles
          if (task.targetChannel) {
            switch (task.targetChannel.type) {
              case 'guild':
                targetInfo = ` ‚Üí üè† Serveur: **${task.targetChannel.guildName}** (salon: ${task.targetChannel.name})`;
                break;
              case 'dm':
                targetInfo = ` ‚Üí üë§ MP: **${task.targetChannel.username}**`;
                break;
              case 'group':
                targetInfo = ` ‚Üí üë• Groupe: **${task.targetChannel.name}** (${task.targetChannel.memberCount} membres)`;
                break;
            }

            if (task.targetUser) {
              targetInfo += ` ‚Üí @${task.targetUser.username}`;
            }
          }

          statusMessage += `‚Ä¢ T√¢che #${task.number} (${task.id}): **${task.nextExecution}** (dans ${task.timeLeft})${targetInfo}\n`;
        });
      }

      // Utiliser la fonction sendLongMessage pour envoyer le message complet en plusieurs parties si n√©cessaire
      try {
        await sendLongMessage(message.channel, statusMessage, { reply: message.reply.bind(message) });
      } catch (error) {
        console.error('Erreur lors de l\'envoi des messages de statut:', error);
        message.channel.send('‚ùå Une erreur est survenue lors de l\'affichage du statut complet.');
      }
      break;

    default:
      message.reply('‚ùå Action non reconnue. Utilisez start, stop, restart ou status.');
  }
}
